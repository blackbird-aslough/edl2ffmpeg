diff --git a/src/media/FFmpegCompat.cpp b/src/media/FFmpegCompat.cpp
index abc123..def456 100644
--- a/src/media/FFmpegCompat.cpp
+++ b/src/media/FFmpegCompat.cpp
@@ -130,6 +130,10 @@ bool FFmpegCompat::encodeVideoFrame(AVCodecContext* codecCtx, AVFrame* frame, AV
 		
 		return true;
 	} else if (ret == AVERROR(EAGAIN)) {
+		// Encoder buffer is full, need to drain packets first
+		// This is not an error - caller should retrieve packets
+		// and try again
+	} else if (ret == AVERROR(EAGAIN)) {
 		// Need to receive packets first
 		Logger::error("encodeVideoFrame: need to receive packets first (EAGAIN)");
 	} else if (ret == AVERROR_EOF) {
diff --git a/src/media/FFmpegDecoder.cpp b/src/media/FFmpegDecoder.cpp
index abc123..def456 100644
--- a/src/media/FFmpegDecoder.cpp
+++ b/src/media/FFmpegDecoder.cpp
@@ -392,6 +392,18 @@ bool FFmpegDecoder::getNextFrameInternal(std::shared_ptr<AVFrame>& outFrame) {
 			utils::Logger::debug("Got hardware frame format={} from decoder", 
 				av_get_pix_fmt_name((AVPixelFormat)hwFrame->format));
 			
+			// First attempt direct transfer for optimal performance (works for VAAPI/NVENC)
+			int transferRet = av_hwframe_transfer_data(frame, hwFrame, 0);
+			
+			if (transferRet < 0) {
+				// Direct transfer failed - this happens with VideoToolbox when format conversion is needed
+				// VideoToolbox often needs format conversion during transfer
+				// Create a new frame with matching properties
+				utils::Logger::debug("Direct hardware transfer failed ({}), trying with temporary frame allocation",
+					transferRet);
+				
+				// Reset frame before retrying
+				av_frame_unref(frame);
 				// Allocate a new frame with matching properties
 				int allocRet = av_frame_get_buffer(frame, 32);
 				if (allocRet < 0) {
@@ -485,7 +497,7 @@ bool FFmpegDecoder::getNextFrameInternal(std::shared_ptr<AVFrame>& outFrame) {
 				// This is the actual hardware frame transfer
 				ret = av_hwframe_transfer_data(frame, hwFrame, 0);
 				if (ret < 0) {
-				char errbuf[AV_ERROR_MAX_STRING_SIZE];
-				av_strerror(ret, errbuf, sizeof(errbuf));
-				utils::Logger::error("Hardware frame transfer failed: {}", errbuf);
-				continue;
+					char errbuf[AV_ERROR_MAX_STRING_SIZE];
+					av_strerror(ret, errbuf, sizeof(errbuf));
+					utils::Logger::error("Hardware frame transfer failed: {}", errbuf);
+					continue;
+				}
 			}
 			
 			outFrame = frame;
diff --git a/src/media/FFmpegEncoder.cpp b/src/media/FFmpegEncoder.cpp
index abc123..def456 100644
--- a/src/media/FFmpegEncoder.cpp
+++ b/src/media/FFmpegEncoder.cpp
@@ -457,6 +457,17 @@ bool FFmpegEncoder::encodeFrame(AVFrame* frame) {
 	// If using hardware encoding and frame is not already a hardware frame,
 	// we need to upload it to GPU memory
 	// Exception: NVENC can handle software frames directly when configured with software pixel format
+	bool needManualUpload = usingHardware && hwDeviceCtx && frame && !HardwareAcceleration::isHardwareFrame(frame);
+	
+	// Skip manual upload for NVENC when it's configured with software pixel format
+	if (needManualUpload && codecCtx && codecCtx->codec && codecCtx->codec->name) {
+		std::string codecName = codecCtx->codec->name;
+		if (codecName.find("nvenc") != std::string::npos && codecCtx->pix_fmt == AV_PIX_FMT_YUV420P) {
+			utils::Logger::debug("NVENC will handle software frame upload internally");
+			needManualUpload = false;
+		}
+	}
+	
 	if (usingHardware && hwDeviceCtx && frame && !HardwareAcceleration::isHardwareFrame(frame)) {
 		utils::Logger::debug("Need to upload software frame to GPU for hardware encoding");
 		// Allocate hardware frame if not already done
@@ -490,18 +502,55 @@ bool FFmpegEncoder::encodeFrame(AVFrame* frame) {
 		}
 	}
 	
-	// Send frame to encoder
-	int ret = avcodec_send_frame(codecCtx, frameToSend);
-	if (ret < 0) {
-		char errbuf[AV_ERROR_MAX_STRING_SIZE];
-		av_strerror(ret, errbuf, sizeof(errbuf));
-		utils::Logger::error("Error sending frame to encoder: {} ({})", errbuf, ret);
-		return false;
+	// Try to send frame and drain any available packets
+	bool frameAccepted = false;
+	int attempts = 0;
+	const int maxAttempts = 10; // Prevent infinite loops
+	
+	while (attempts < maxAttempts) {
+		attempts++;
+		
+		// Try to send frame if not yet accepted
+		if (!frameAccepted) {
+			int ret = avcodec_send_frame(codecCtx, frameToSend);
+			if (ret == 0) {
+				frameAccepted = true;
+			} else if (ret == AVERROR(EAGAIN)) {
+				// Need to drain packets first
+			} else if (ret < 0 && ret != AVERROR_EOF) {
+				char errbuf[AV_ERROR_MAX_STRING_SIZE];
+				av_strerror(ret, errbuf, sizeof(errbuf));
+				utils::Logger::error("Error sending frame to encoder: {} ({})", errbuf, ret);
+				return false;
+			}
+		}
+		
+		// Try to receive packet
+		int ret = avcodec_receive_packet(codecCtx, packet);
+		if (ret == 0) {
+			// Got a packet, write it
+			av_packet_rescale_ts(packet, codecCtx->time_base, videoStream->time_base);
+			packet->stream_index = videoStream->index;
+			
+			ret = av_interleaved_write_frame(formatCtx, packet);
+			av_packet_unref(packet);
+			
+			if (ret < 0) {
+				utils::Logger::error("Error writing packet");
+				return false;
+			}
+			
+			frameCount++;
+			// Continue draining
+		} else if (ret == AVERROR(EAGAIN)) {
+			// No more packets available
+			if (frameAccepted) {
+				// Frame was accepted, we're done
+				break;
+			}
+			// Frame not accepted and no packets to drain - this is an error
+			utils::Logger::error("Encoder deadlock: cannot send frame and no packets to drain");
+			return false;
+		} else if (ret == AVERROR_EOF) {
+			// Encoder has been flushed
+			break;
+		} else {
+			char errbuf[AV_ERROR_MAX_STRING_SIZE];
+			av_strerror(ret, errbuf, sizeof(errbuf));
+			utils::Logger::error("Error receiving packet from encoder: {} ({})", errbuf, ret);
+			return false;
+		}
 	}
 	
-	// Get encoded packet
-	frameCount++;
-	return true;
+	if (!frameAccepted && attempts >= maxAttempts) {
+		utils::Logger::error("Failed to send frame after {} attempts", maxAttempts);
+		return false;
+	}
+	
+	return true;
 }
 
 bool FFmpegEncoder::flushEncoder() {
diff --git a/src/media/HardwareAcceleration.cpp b/src/media/HardwareAcceleration.cpp
index abc123..def456 100644
--- a/src/media/HardwareAcceleration.cpp
+++ b/src/media/HardwareAcceleration.cpp
@@ -266,6 +266,14 @@ int HardwareAcceleration::transferSWFrameToHW(AVFrame* swFrame, AVFrame* hwFrame
 		return AVERROR(EINVAL);
 	}
 	
+	// Allocate buffer for the hardware frame if not already allocated
+	if (!hwFrame->buf[0]) {
+		int ret = av_hwframe_get_buffer(hwFrame->hw_frames_ctx, hwFrame, 0);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	
 	// Transfer data from software frame to hardware frame
 	return av_hwframe_transfer_data(hwFrame, swFrame, 0);
 }